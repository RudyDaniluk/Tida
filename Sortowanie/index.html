<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorytmy Sortowania - Wizualizacja</title>
    <style>
        table {
            width: 100%;
            border-collapse: collapse;
        }
        table, th, td {
            border: 1px solid black;
        }
        th, td {
            padding: 10px;
            text-align: left;
            vertical-align: top;
        }
        th {
            background-color: #f2f2f2;
        }
        .steps-list {
            list-style-type: decimal;
            padding-left: 20px;
        }
        td:first-child {
            width: 25%;
        }
        td:nth-child(2) {
            width: 50%;
        }
        td:last-child {
            width: 25%;
        }
        img {
            max-width: 100%; 
            height: auto;    
            display: block;
            margin: 0 auto;  
        }
        .visualization-button {
            margin-top: 10px;
            padding: 5px 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #canvas {
            display: block; 
            margin: 20px auto; 
            border: 1px solid black;
        }
    </style>
</head>
<body>
    
    <h1>Struktura algorytmu</h1>

    <table>
        <thead>
            <tr>
                <th>A - Lista kroków</th>
                <th>B - Zdjęcie kodu źródłowego algorytmu</th>
                <th>C - Zdjęcie schematu blokowego algorytmu</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>
                    <h2>Sortowanie przez wstawianie</h2>
                    <ol class="steps-list">
                        <li>Przejdź przez zbiór od drugiego elementu do ostatniego.</li>
                        <li>Wybierz bieżący element i oznacz go jako element do wstawienia.</li>
                        <li>Porównuj wybrany element z elementami wcześniejszymi, zaczynając od elementu bezpośrednio przed nim.</li>
                        <li>Jeżeli istnieje element przed elementem wybranym i jest od niego większy, przesuń ten element w prawo.</li>
                        <li>Wstaw wybrany element w miejsce "dziury" powstałej po przesunięciu elementów większych.</li>
                        <li>Powtarzaj kroki 2-5 dla każdego kolejnego elementu w zbiorze.</li>
                        <li>Zakończ proces sortowania i wyeksportuj uporządkowany zbiór danych.</li>
                    </ol>
                    <button class="visualization-button" onclick="startVisualization('insertionSort')">Uruchom wizualizację</button>
                </td>
                <td>
                    <img src="img/insert.png" alt="Zdjęcie kodu algorytmu">
                </td>
                <td>
                    <img src="img/insertB.png" alt="Schemat blokowy algorytmu">
                </td>
            </tr>
            <tr>
                <td>
                    <h2>Sortowanie przez wybieranie</h2>
                    <ol class="steps-list">
                        <li>Przejdź przez zbiór danych, aby znaleźć najmniejszy element.</li>
                        <li>Wymień najmniejszy element z pierwszym elementem zbioru.</li>
                        <li>Przejdź do kolejnej pozycji i powtórz proces dla pozostałej części zbioru.</li>
                        <li>Kontynuuj, aż wszystkie elementy będą uporządkowane.</li>
                    </ol>
                    <button class="visualization-button" onclick="startVisualization('selectionSort')">Uruchom wizualizację</button>
                </td>
                <td>
                    <img src="img/choise.png" alt="Zdjęcie kodu algorytmu">
                </td>
                <td>
                    <img src="img/choiceB.png" alt="Schemat blokowy algorytmu">
                </td>
            </tr>
            <tr>
                <td>
                    <h2>Sortowanie szybkie</h2>
                    <ol class="steps-list">
                        <li>Wybierz element pivot (może to być pierwszy, ostatni lub losowy element).</li>
                        <li>Podziel zbiór na dwie podgrupy: mniejsze od pivotu i większe od pivotu.</li>
                        <li>Rekurencyjnie zastosuj algorytm sortowania do obu podgrup.</li>
                        <li>Po posortowaniu podgrup, scal je, umieszczając pivot pomiędzy nimi.</li>
                    </ol>
                    <button class="visualization-button" onclick="startVisualization('quickSort')">Uruchom wizualizację</button>
                </td>
                <td>
                    <img src="img/quick.png" alt="Zdjęcie kodu algorytmu">
                </td>
                <td>
                    <img src="img/quickB.png" alt="Schemat blokowy algorytmu">
                </td>
            </tr>
            <tr>
                <td>
                    <h2>Sortowanie przez scalanie</h2>
                    <ol class="steps-list">
                        <li>Podziel zbiór danych na dwie połówki.</li>
                        <li>Rekurencyjnie zastosuj algorytm sortowania przez scalanie dla każdej z połówek.</li>
                        <li>Scalaj posortowane połówki w celu utworzenia posortowanego zbioru:</li>
                        <ol>
                            <li>Utwórz nową tablicę lub listę, która będzie przechowywać scalone elementy.</li>
                            <li>Porównuj elementy z obu połówek, zaczynając od ich początków.</li>
                            <li>Dodawaj mniejszy element do scalanej tablicy/listy.</li>
                            <li>Jeśli jedna z połówek zostanie już w pełni przeanalizowana, dodaj pozostałe elementy z drugiej połowy do scalanej tablicy/listy.</li>
                            <li>Powtarzaj te kroki, aż obie połówki zostaną w pełni rozwiązane i wszystkie elementy zostaną umieszczone w scalonej tablicy/liście.</li>
                        </ol>
                        <li>Zwróć scalony zbiór.</li>
                    </ol>
                    <button class="visualization-button" onclick="startVisualization('mergeSort')">Uruchom wizualizację</button>
                </td>
                <td>
                    <img src="img/merge.png" alt="Zdjęcie kodu algorytmu">
                </td>
                <td>
                    <img src="img/mergeB.png" alt="Schemat blokowy algorytmu">
                </td>
            </tr>
            <tr>
                <td>
                    <h2>Sortowanie bąbelkowe</h2>
                    <ol class="steps-list">
                        <li>Przejdź przez cały zestaw danych, porównując sąsiednie elementy.</li>
                        <li>Jeśli sąsiadujące ze sobą elementy są w złej kolejności (np. element poprzedni jest większy od następnego), zamień je miejscami.</li>
                        <li>Powtórz krok 1 dla wszystkich pozostałych elementów, aż dotrzesz do ostatniej pary elementów.</li>
                        <li>Po zakończeniu pierwszej iteracji największy element powinien znaleźć się na końcu kolekcji.</li>
                        <li>Powtórz kroki 1-4 dla n-1 elementów, gdzie n jest rozmiarem kolekcji.</li>
                        <li>Po zakończeniu wszystkich iteracji, cała kolekcja powinna być uporządkowana rosnąco.</li>
                    </ol>
                    <button class="visualization-button" onclick="startVisualization('bubbleSort')">Uruchom wizualizację</button>
                </td>
                <td>
                    <img src="img/bubble.png" alt="Zdjęcie kodu algorytmu">
                </td>
                <td>
                    <img src="img/bubbleB.png" alt="Schemat blokowy algorytmu">
                </td>
            </tr>
        </tbody>
    </table>

    <canvas id="canvas" width="1500" height="400"></canvas>

    <script>
     let array = [];
let animationFrameId;
let isSorting = false;
let currentIndex = 0;

function generateArray(size) {
    array = Array.from({ length: size }, () => Math.floor(Math.random() * 100));
}

function drawArray(array) {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const width = canvas.width / array.length;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    array.forEach((value, index) => {
        ctx.fillStyle = 'blue';
        ctx.fillRect(index * width, canvas.height - value * 4, width - 2, value * 4);
    });
}


function stopAnimation() {
    if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
    }
    isSorting = false;
    currentIndex = 0;
}

function startVisualization(algorithm) {
    if (isSorting) return;
    isSorting = true;
    stopAnimation();
    generateArray(200);
    drawArray(array);

    const canvas = document.getElementById('canvas');
    canvas.scrollIntoView({ behavior: 'smooth' });

    switch (algorithm) {
        case 'insertionSort':
            insertionSort();
            break;
        case 'selectionSort':
            selectionSort();
            break;
        case 'quickSort':
            quickSort();
            break;
        case 'mergeSort':
            mergeSort();
            break;
        case 'bubbleSort':
            bubbleSort();
            break;
    }
}

function insertionSort() {
    currentIndex = 1; 
    animationFrameId = requestAnimationFrame(insertionSortStep);
}

function insertionSortStep() {
    if (currentIndex >= array.length) {
        stopAnimation();
        return;
    }
    let key = array[currentIndex];
    let j = currentIndex - 1;

    while (j >= 0 && array[j] > key) {
        array[j + 1] = array[j];
        j--;
        drawArray(array);
    }
    array[j + 1] = key;
    drawArray(array);
    
    setTimeout(() => {
        currentIndex++;
        animationFrameId = requestAnimationFrame(insertionSortStep);
    }, 150);
}

function selectionSort() {
    currentIndex = 0; 
    animationFrameId = requestAnimationFrame(selectionSortStep);
}

function selectionSortStep() {
    if (currentIndex >= array.length - 1) {
        stopAnimation();
        return;
    }
    
    let minIndex = currentIndex;
    for (let j = currentIndex + 1; j < array.length; j++) {
        if (array[j] < array[minIndex]) {
            minIndex = j;
        }
    }
    // Zamiana
    [array[currentIndex], array[minIndex]] = [array[minIndex], array[currentIndex]];
    drawArray(array);
    
    setTimeout(() => {
        currentIndex++;
        animationFrameId = requestAnimationFrame(selectionSortStep);
    }, 150);
}

function quickSort() {
    let stack = [{ left: 0, right: array.length - 1 }];
    animationFrameId = requestAnimationFrame(quickSortStep);
}

function quickSortStep() {
    if (stack.length === 0) {
        stopAnimation();
        return;
    }

    const { left, right } = stack.pop();
    if (left < right) {
        const pivotIndex = partition(left, right);
        stack.push({ left: left, right: pivotIndex - 1 });
        stack.push({ left: pivotIndex + 1, right: right });
    }
    drawArray(array);
    animationFrameId = requestAnimationFrame(quickSortStep);
}

function partition(left, right) {
    const pivot = array[right];
    let i = left - 1;
    for (let j = left; j < right; j++) {
        if (array[j] < pivot) {
            i++;
            [array[i], array[j]] = [array[j], array[i]];
        }
    }
    [array[i + 1], array[right]] = [array[right], array[i + 1]];
    return i + 1;
}

function mergeSort() {
    const sort = (arr) => {
        if (arr.length <= 1) return arr;
        const mid = Math.floor(arr.length / 2);
        const left = sort(arr.slice(0, mid));
        const right = sort(arr.slice(mid));
        return merge(left, right);
    };

    const merge = (left, right) => {
        const result = [];
        let i = 0, j = 0;

        while (i < left.length && j < right.length) {
            if (left[i] < right[j]) {
                result.push(left[i]);
                i++;
            } else {
                result.push(right[j]);
                j++;
            }
        }
        return [...result, ...left.slice(i), ...right.slice(j)];
    };

    const sortedArray = sort(array);
    let index = 0;

    animationFrameId = requestAnimationFrame(function mergeStep() {
        if (index >= sortedArray.length) {
            array = sortedArray;
            drawArray(array);
            stopAnimation();
            return;
        }
        array[index] = sortedArray[index];
        drawArray(array);
        
        setTimeout(() => {
            index++;
            animationFrameId = requestAnimationFrame(mergeStep);
        }, 150); 
    });
}

function bubbleSort() {
    currentIndex = 0; 
    animationFrameId = requestAnimationFrame(bubbleSortStep);
}

function bubbleSortStep() {
    if (currentIndex >= array.length - 1) {
        stopAnimation();
        return;
    }

    let swapped = false;
    for (let j = 0; j < array.length - currentIndex - 1; j++) {
        if (array[j] > array[j + 1]) {
            [array[j], array[j + 1]] = [array[j + 1], array[j]];
            swapped = true;
        }
    }
    drawArray(array);
    
    setTimeout(() => {
        currentIndex++;
        if (swapped) {
            animationFrameId = requestAnimationFrame(bubbleSortStep);
        } else {
            stopAnimation();
        }
    }, 150);
}

</script>
</body>
</html>
